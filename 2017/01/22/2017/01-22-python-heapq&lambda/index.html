<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> heapq 和 lambda · Qiyexuxu</title><meta name="description" content="heapq 和 lambda - David Wang"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://blog.keeplearning.group/atom.xml" title="Qiyexuxu"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/logo.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/abnerwang" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">heapq 和 lambda</h1><div class="tags"><a href="/tags/Python/" class="tag-title">#Python</a></div><div class="post-info">Jan 22, 2017</div><div class="post-content"><p>要想找出一组值中的最大、最小的 <code>n</code> 个值，就要利用到 <code>heapq</code> 中的 <code>nlargest()</code> 和 <code>nsmallest()</code> 两个函数：</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"> </span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">0</span>]</span><br><span class="line">print(heapq.nlargest(<span class="number">3</span>, nums))    <span class="comment"># [9, 8, 7]</span></span><br><span class="line">print(heapq.nsmallest(<span class="number">3</span>, nums))   <span class="comment"># [0, 1, 2]</span></span><br></pre></td></tr></table></figure>
<p>这两个函数都可以接受一个参数 <code>key</code>，从而允许它们工作在更加复杂的数据结构之上：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"> </span><br><span class="line">portfolio = [</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'IBM'</span>, <span class="string">'shares'</span>: <span class="number">100</span>, <span class="string">'price'</span>: <span class="number">91.1</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'AAPL'</span>, <span class="string">'shares'</span>: <span class="number">50</span>, <span class="string">'price'</span>: <span class="number">543.22</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'FB'</span>, <span class="string">'shares'</span>: <span class="number">200</span>, <span class="string">'price'</span>: <span class="number">21.09</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'HPQ'</span>, <span class="string">'shares'</span>: <span class="number">35</span>, <span class="string">'price'</span>: <span class="number">31.75</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'YHOO'</span>, <span class="string">'shares'</span>: <span class="number">45</span>, <span class="string">'price'</span>: <span class="number">16.35</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'ACME'</span>, <span class="string">'shares'</span>: <span class="number">75</span>, <span class="string">'price'</span>: <span class="number">115.65</span>&#125;</span><br><span class="line">]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">cheap = heapq.nsmallest(<span class="number">3</span>, portfolio, key=<span class="keyword">lambda</span> s: s[<span class="string">'price'</span>])</span><br><span class="line">expensive = heapq.nlargest(<span class="number">3</span>, portfolio, key=<span class="keyword">lambda</span> s: s[<span class="string">'price'</span>])</span><br><span class="line"> </span><br><span class="line">print(cheap)</span><br><span class="line">print(expensive)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 结果为：</span></span><br><span class="line"><span class="comment"># [&#123;'name': 'YHOO', 'shares': 45, 'price': 16.35&#125;, &#123;'name': 'FB', 'shares': 200, 'price': 21.09&#125;, &#123;'name': 'HPQ', 'shares': 35, 'price': 31.75&#125;]</span></span><br><span class="line"><span class="comment"># [&#123;'name': 'AAPL', 'shares': 50, 'price': 543.22&#125;, &#123;'name': 'ACME', 'shares': 75, 'price': 115.65&#125;, &#123;'name': 'IBM', 'shares': 100, 'price': 91.1&#125;]</span></span><br></pre></td></tr></table></figure>
<p>上面的代码似乎有些难于理解，从 <a href="http://stackoverflow.com/questions/8966538/syntax-behind-sortedkey-lambda" target="_blank" rel="noopener">StackOverflow</a> 了解到，<code>lambada</code> 的作用是创建一个匿名函数，<code>lambda</code> 的后面跟着参数名列表，然后再在其后跟着一个代码块，参数名列表和代码块之间用分号隔开，这样子的结构在 <code>Python</code> 中与 <code>while</code>、<code>for</code> 和 <code>if</code>类似，它们都是拥有代码块的典型代表，<code>lambda</code> 只是另外一个代表而已。我们可以比较一下利用 <code>lambda</code> 和 <code>def</code> 定义函数的不同：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">adder_lambda = <span class="keyword">lambda</span> parameter1, parameter2: parameter1 + parameter2</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">adder_regular</span><span class="params">(parameter1, parameter2)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> parameter1 + parameter2</span><br></pre></td></tr></table></figure>
<p><code>lambda</code> 给我们提供了一种完成类似这样子任务的方式而不用为函数取一个名字，相对于一个 <code>def</code> 定义的函数来说这样子要好得多。</p>
<p>对于 <code>nlargest</code> 和 <code>nsmallest</code> 两个函数中增加 <code>key</code> 参数，根据<a href="https://docs.python.org/3/library/heapq.html?highlight=heapq#module-heapq" target="_blank" rel="noopener"> <code>Python documentation</code></a> 中描述的那样，上面的两条语句分别相当于：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cheap = sorted(portfolio, key=<span class="keyword">lambda</span> s: s[<span class="string">'price'</span>])[:<span class="number">3</span>]</span><br><span class="line">expensive = sorted(portfolio, key=<span class="keyword">lambda</span> s: s[<span class="string">'price'</span>], reverse=<span class="keyword">True</span>)[:<span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p>为了验证正确性，不妨运行一下下面的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"> </span><br><span class="line">portfolio = [</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'IBM'</span>, <span class="string">'shares'</span>: <span class="number">100</span>, <span class="string">'price'</span>: <span class="number">91.1</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'AAPL'</span>, <span class="string">'shares'</span>: <span class="number">50</span>, <span class="string">'price'</span>: <span class="number">543.22</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'FB'</span>, <span class="string">'shares'</span>: <span class="number">200</span>, <span class="string">'price'</span>: <span class="number">21.09</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'HPQ'</span>, <span class="string">'shares'</span>: <span class="number">35</span>, <span class="string">'price'</span>: <span class="number">31.75</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'YHOO'</span>, <span class="string">'shares'</span>: <span class="number">45</span>, <span class="string">'price'</span>: <span class="number">16.35</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'ACME'</span>, <span class="string">'shares'</span>: <span class="number">75</span>, <span class="string">'price'</span>: <span class="number">115.65</span>&#125;</span><br><span class="line">]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">cheap = heapq.nsmallest(<span class="number">3</span>, portfolio, key=<span class="keyword">lambda</span> s: s[<span class="string">'price'</span>])</span><br><span class="line">cheap_copy = sorted(portfolio, key=<span class="keyword">lambda</span> s: s[<span class="string">'price'</span>])[:<span class="number">3</span>]</span><br><span class="line">expensive = heapq.nlargest(<span class="number">3</span>, portfolio, key=<span class="keyword">lambda</span> s: s[<span class="string">'price'</span>])</span><br><span class="line">expensive_copy = sorted(portfolio, key=<span class="keyword">lambda</span> s: s[<span class="string">'price'</span>], reverse=<span class="keyword">True</span>)[:<span class="number">3</span>]</span><br><span class="line"> </span><br><span class="line">print(cheap == cheap_copy)    <span class="comment"># True</span></span><br><span class="line">print(expensive == expensive_copy)   <span class="comment"># True</span></span><br></pre></td></tr></table></figure>
<p>由此可见上面的说法是完全正确的。</p>
<p>需要特别注意的是，在 <code>nlargest</code> 和 <code>nsmallest</code> 函数中以及在 <code>sorted</code> 中的 <code>key</code> 返回的必须是具体的数值，切莫想当然地以为是 <code>price</code>，而是 <code>price</code> 的 <code>value</code>。</p>
<p>堆最重要的特性就是 <code>heap[0]</code> 总是最小的那个元素，此外，接下来的最小元素可以依次通过 <code>heapq.pop()</code> 方法轻松找到，该方法会将第一个元素（最小的）弹出，然后会以第二小的元素取而代之。当所要找的元素数量 N 相对较小时，函数 <code>nlargest()</code> 和 <code>nsmallest()</code> 才是最适用的。如果只是简单地想找到最小或最大的元素（N=1时），那么用 <code>min()</code> 和 <code>max()</code> 会更加快。同样，如果 N 和集合本身的大小差不多大，通常更快的方法是先对集合排序，然后做切片操作（例如使用 <code>sorted(items)[:N]</code> 或者 <code>sorted(items)[:-N]</code>。应该要注意的是，<code>nlargest()</code> 和 <code>nsmallest()</code> 的实际实现会根据使用它们的方式而有所不同，可能会相应作出一些优化措施（比如，当 N 的大小同输入大小很接近时，就会采用排序方法）。</p>
<p>可以使用 <code>heapify</code> 将一个列表转换成堆。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">23</span>, <span class="number">7</span>, <span class="number">-4</span>, <span class="number">18</span>, <span class="number">23</span>, <span class="number">42</span>, <span class="number">37</span>, <span class="number">2</span>]</span><br><span class="line">heap = list(nums)</span><br><span class="line">heapq.heapify(heap)</span><br><span class="line">print(heap)         <span class="comment"># [-4, 2, 1, 23, 7, 2, 18, 23, 42, 37, 8]</span></span><br></pre></td></tr></table></figure>
</div></article></div></main><footer><div class="paginator"><a href="/2017/04/17/2017/04-15-hejiuhaojie/" class="prev">PREV</a><a href="/2017/01/21/2017/01-21-python-yield&amp;deque/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'abnerwang';
var disqus_identifier = '2017/01/22/2017/01-22-python-heapq&amp;lambda/';
var disqus_title = 'heapq 和 lambda';
var disqus_url = 'http://blog.keeplearning.group/2017/01/22/2017/01-22-python-heapq&amp;lambda/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//abnerwang.disqus.com/count.js" async></script><div class="copyright"><p>© 2014 - 2018 <a href="http://blog.keeplearning.group">David Wang</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>