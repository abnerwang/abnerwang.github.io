<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Qiyexuxu</title><meta name="description" content="王小平的个人博客"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://blog.keeplearning.group/atom.xml" title="Qiyexuxu"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/logo.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/abnerwang" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2014/03/31/2014/03-31-c++-processing-type copy/" class="post-title-link">C++ 中的处理类型</a></h2><div class="tags"><a href="/tags/C/" class="tag-title">#C++</a></div><div class="post-info">Mar 31, 2014</div><div class="post-content"><ol>
<li><p>类型别名</p>
<p>有两种方法可以定义类型别名：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> wages;  <span class="comment">// wages 是 double 的同义词</span></span><br><span class="line"><span class="keyword">typedef</span> wages *p;  <span class="comment">// p 是 double* 的同义词</span></span><br></pre></td></tr></table></figure>
<p>新标准规定了一种新的方法：</p></li></ol></div><a href="/2014/03/31/2014/03-31-c++-processing-type copy/" class="read-more">MORE</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2014/03/27/2014/03-27-c++-void-pointer/" class="post-title-link">void* 指针</a></h2><div class="tags"><a href="/tags/C/" class="tag-title">#C++</a></div><div class="post-info">Mar 27, 2014</div><div class="post-content"><p><code>void*</code> 指针是一种特殊的指针类型，<strong>可以存放任意对象的地址</strong>，一个 <code>void*</code> 指针存放着一个地址，这一点和其他指针类似，不同的是，<strong>我们对该地址中到底是个什么类型的对象并不了解</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> obj = <span class="number">3.14</span>, *pd = &amp;obj;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> *pv = &amp;obj;  <span class="comment">// 正确：void* 能存放任意类型对象的地址  </span></span><br><span class="line">pv = pd;  <span class="comment">// pv 可以存放任意类型的指针</span></span><br></pre></td></tr></table></figure>
<p>利用 <code>void*</code> 指针能做的事儿比较有限：拿它和别的指针比较、作为函数的输入或输出，或者赋给另外一个<strong><code>void*</code> 指针</strong>，<strong>不能直接操作 <code>void*</code> 指针所指的对象</strong>，因为我们并不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。</p></div><a href="/2014/03/27/2014/03-27-c++-void-pointer/" class="read-more">MORE</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2014/03/12/2014/03-12-c++-escape-seq/" class="post-title-link">C++ 中的转义序列</a></h2><div class="tags"><a href="/tags/C/" class="tag-title">#C++</a></div><div class="post-info">Mar 12, 2014</div><div class="post-content"><p>本文来简单地谈谈 C++ 的转义序列，有两类字符程序员不能直接使用，第一类是不可打印的字符，如换行符，响铃符，制表符等等，这些字符没有办法通过直接输入得到直接的输出，第二类是在 C++ 中有特殊含义的字符，这类字符同样没有办法通过直接输入得到直接的输出，这两类字符都只能通过转义序列进行实现，C++ 语言规定的转义序列包括：</p></div><a href="/2014/03/12/2014/03-12-c++-escape-seq/" class="read-more">MORE</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2014/03/07/2014/03-07-c++-unsigend-exp/" class="post-title-link">C++ 中含有无符号类型的表达式</a></h2><div class="tags"><a href="/tags/C/" class="tag-title">#C++</a></div><div class="post-info">Mar 7, 2014</div><div class="post-content"><p>对于一个无符号类型和一个有符号类型的加法问题，参见 <a href="https://abnerwang.blog.ustc.edu.cn/c-%E4%B8%AD%E6%9C%89%E7%AC%A6%E5%8F%B7%E7%B1%BB%E5%9E%8B%E5%88%B0%E6%97%A0%E7%AC%A6%E5%8F%B7%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2/" target="_blank" rel="noopener">C++ 中有符号类型到无符号类型的转换</a> ，下面我们来谈谈<strong>一个无符号类型减去一个值的情形</strong>，首先看下面的代码：</p></div><a href="/2014/03/07/2014/03-07-c++-unsigend-exp/" class="read-more">MORE</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2014/03/07/2014/03-07-c++-types/" class="post-title-link">C++ 中的基本内置类型以及编程过程中对于类型的选择建议</a></h2><div class="tags"><a href="/tags/C/" class="tag-title">#C++</a></div><div class="post-info">Mar 7, 2014</div><div class="post-content"><p>C++ 中定义了包括 <strong>算术类型</strong> 和 <strong>空类型</strong> 在内的数据类型，空类型一般只用于特定的场合，例如在程序运行完毕后补要求返回任何值时，可对函数类型用空类型，算术类型总的来说包括两个方面：<strong>整型</strong>(包括字符型以及布尔型在内) 和 <strong>浮点型</strong>，C++ 标准只是规定了算术类型所占的最小比特位：</p></div><a href="/2014/03/07/2014/03-07-c++-types/" class="read-more">MORE</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2014/03/06/2014/03-06-c++-signed-to-unsigned/" class="post-title-link">C++ 中有符号类型到无符号类型的转换</a></h2><div class="tags"><a href="/tags/C/" class="tag-title">#C++</a></div><div class="post-info">Mar 6, 2014</div><div class="post-content"><p>为了更好地解释下面的代码，先来介绍一些背景知识，在我的计算机中， char 类型占 8 个比特位，那么， unsigned char 类型能表示的数的范围为 0 ~ 2的8次方 – 1，即 0 ~ 255，共 256 个数；int 类型占 32 个比特位，那么 unsigned 类型所能表示的数的范围为 0 ~ 2的32次方 – 1，即 0 ~ 4294967295，共 4294967296 个数，接下来看下面的代码：</p></div><a href="/2014/03/06/2014/03-06-c++-signed-to-unsigned/" class="read-more">MORE</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2014/03/06/2014/03-06-c++-errors/" class="post-title-link">C++ Primer 中文版第五版错误（持续更新中）</a></h2><div class="tags"><a href="/tags/C/" class="tag-title">#C++</a></div><div class="post-info">Mar 6, 2014</div><div class="post-content"><p>这篇文章是对 <a href="http://book.douban.com/subject/25708312/" target="_blank" rel="noopener">《C++ Primer 中文版第5版》</a> 中错误的列举，会随着时间的推移持续更新</p></div><a href="/2014/03/06/2014/03-06-c++-errors/" class="read-more">MORE</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2014/03/01/2014/03-01-c++-input/" class="post-title-link">有关C++输入，类，文件重定向的使用和成员函数的简单小结</a></h2><div class="tags"><a href="/tags/C/" class="tag-title">#C++</a></div><div class="post-info">Mar 1, 2014</div><div class="post-content"><ol>
<li><p>读取数量不定的输入数据</p>
<p>在日常生活中，我们经常需要处理的是输入数据量不确定的数据，那么，在 C++ 语言中怎样将这些数量不确定的数据输入到计算机呢？譬如，我们输入不定量的数据后，求这些数据的和， C++ 中是怎么实现的呢？说来也很简单，看看下面的代码吧：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, val = <span class="number">0</span>;   <span class="comment">/* 变量的初始化 */</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; val)  <span class="comment">/* 读取数量不定的输入数据 */</span></span><br><span class="line">        sum + = val;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Sum is "</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由上面非常简单的一个小程序我们可以看到，实现读取不定数量的输入数据是依靠 <code>while (std::cin &gt;&gt; val)</code> 来实现的，表达式 <code>std::cin &gt;&gt; val</code> 从标准输入读取数据后存入变量 <code>val</code> 并且返回一个 istream 对象（输入运算符返回其左侧运算对象，即 <code>std::cin</code> ），也就是说， <code>while</code> 循环的条件是一个 istream 类型的对象，其效果是检测流的状态，如果流是有效的，即流没有遇到错误，那么检测成功，当遇到<strong>文件结束符或者一个无效的输入时（例如在以上程序中读入的值不是一个整数）</strong>，条件变假</p>
<p>从键盘输入文件结束符：<br>Windows: Ctrl + Z，然后按 Enter 或 Return 键<br>UNIX/Mac OS X: Ctrl + D</p>
</li>
</ol></div><a href="/2014/03/01/2014/03-01-c++-input/" class="read-more">MORE</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2014/02/11/2014/02-11-c++-iostream/" class="post-title-link">C++ 中关于 iostream、源文件命名约定以及运行 GNU (微软)编译器的几点说明</a></h2><div class="tags"><a href="/tags/C/" class="tag-title">#C++</a></div><div class="post-info">Feb 11, 2014</div><div class="post-content"><ol>
<li><p>关于 <code>#include &lt;iostream&gt;</code></p>
<p>在一个C++程序中，几乎都需要有这么一条语句<code>#include &lt;iostream&gt;</code>，以致于我们每写一个C++程序，都习惯性地先写下这条语句，再接着写程序的其他部分，由于写下这条语句是习惯性的动作，所以我估计很少有人真正花时间回想一下这究竟是什么东西？为什么在一个C++程序中要写这条语句？说来也很简单：</p>
<p>在C++中，没有专门用来进行输入输出(IO)的语句，而是用标准库来提供IO机制，我们通常只需要了解IO库中的一部分基本概念和操作，iostream 库包括两个基础类型：<strong>istream 类型</strong>和 <strong>ostream 类型</strong>，分别表示输入流和输出流。</p>
<blockquote>
<p><strong>标准库定义了4个IO对象:</strong></p>
<ul>
<li>cin (发音为 see-in) —— istream 类型的对象，也被称为标准输入</li>
<li>cout (发音为 see-out) —— ostream 类型的对象，也被称为标准输出</li>
<li>cerr (发音为 see-err) —— ostream 类型的对象，通常用来输出警告和错误信息</li>
<li>clog (发音为 see-log) —— ostream 类型的对象，输出程序运行时的一般性信息</li>
</ul>
</blockquote>
<p>系统通常将程序所运行的窗口与这些对象关联起来。</p>
<p><code>#include &lt;iostream&gt;</code>是告诉编译器我们想使用 iostream 库，尖括号中的名字指出了一个头文件，每个使用标准库设施的程序都必须包含相关的头文件，<code>#include</code>指令和头文件的名字必须出现在同一行中。</p></li></ol></div><a href="/2014/02/11/2014/02-11-c++-iostream/" class="read-more">MORE</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2014/02/09/2014/02-09-why-blog/" class="post-title-link">我为什么要写博客</a></h2><div class="tags"><a href="/tags/随笔/" class="tag-title">#随笔</a></div><div class="post-info">Feb 9, 2014</div><div class="post-content"><p><img src="http://ww3.sinaimg.cn/mw690/79225320gw1edfn0c2aijj20i909rjs2.jpg" alt=""></p>
<p>为什么要写博客？就像上面那张图片中说的那样，生活是点点滴滴的累积。</p>
<p>以前觉得根本就没有写什么博客的需要，因为觉得是浪费时间，与其把时间投入在写博客这件事情上，还不如多去看点书，现在看来，写技术博客，能带来的好处主要有以下几点：</p></div><a href="/2014/02/09/2014/02-09-why-blog/" class="read-more">MORE</a></article></li></ul></main><footer><div class="paginator"><a href="/page/6/" class="prev">PREV</a></div><div class="copyright"><p>© 2014 - 2018 <a href="http://blog.keeplearning.group">David Wang</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>