<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 分治策略结合递归思想求最大子序列和 · Qiyexuxu</title><meta name="description" content="分治策略结合递归思想求最大子序列和 - David Wang"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://blog.keeplearning.group/atom.xml" title="Qiyexuxu"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/logo.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/abnerwang" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">分治策略结合递归思想求最大子序列和</h1><div class="tags"><a href="/tags/算法/" class="tag-title">#算法</a></div><div class="post-info">Jun 30, 2014</div><div class="post-content"><p>对于 <a href="http://book.douban.com/subject/1139426/" target="_blank" rel="noopener">《数据结构与算法分析——C语言描述》</a> 一书第 20 页所描述的算法 3，相信会有很多人表示不怎么理解，下面我由具体问题的求解过程出发，谈谈我自己的理解：</p>
<p>首先，什么是分治法呢？所谓 <strong>分治法</strong>，就是 <strong>将一个问题的求解过程分解为两个大小相等的子问题进行求解，如果分解后的子问题本身也可以分解的话，则将这个分解的过程进行下去，直至最后得到的子问题不能再分解为止</strong>，最后将子问题的解逐步合并并可能做一些少量的附加工作，得到最后整个问题的解。在求解原来整个问题的算法思想，与求解每一个子问题的算法思想完全相同，则可以用到递归来解决这个问题，在我的博文 <a href="https://abnerwang.blog.ustc.edu.cn/%E5%85%B3%E4%BA%8E%E9%80%92%E5%BD%92%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E6%83%B3%E6%B3%95/" target="_blank" rel="noopener">关于递归的一些简单想法</a> 中，曾指出，当我们要解决的问题有着 <strong>反复执行的基本操作</strong> 的时候，可以考虑使用递归，在这里，原来的整个的问题与每一个分解后子问题都有着反复执行的算法思想，这就是一个基本操作，所以可以用递归实现，关于递归，在我的博文 <a href="https://abnerwang.blog.ustc.edu.cn/%E7%94%B1%E9%80%92%E5%BD%92%E6%80%9D%E6%83%B3%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/" target="_blank" rel="noopener">由递归思想处理问题的基本原则</a>中，给出了有关递归思想的部分描述。</p>
<a id="more"></a>
<p>回到我们标题所阐述的问题，求最大子序列和，我们可以将求最大子序列和的序列分解为两个大小相等的子序列，然后在这两个大小相等的子序列中，分别求最大子序列和，如果由原序列分解的这两个子序列还可以进行分解的话，进一步分解，直到不能进行分解为止，使问题逐步简化，最后求最简化的序列的最大子序列和，沿着分解路径逐步回退，合成为最初问题的解。我们知道，最大子序列和只可能在三个位置求出：</p>
<ol>
<li>序列的左半部分的最大子序列和</li>
<li>序列的右半部分的最大子序列和</li>
<li>横跨序列左半部分和右半部分得到的最大子序列和：对包含左半部分的最后一个元素的最大子序列和以及包含右半部分第一个元素的最大子序列和二者求和所得到的值</li>
<li>比较三者的大小，最大者即为所求的最大子序列和</li>
</ol>
<p>下面我们通过具体的实例来仔细体会一下这种 <strong>分治</strong> 的算法思想。</p>
<p>如果我们要求下面序列的最大子序列：</p>
<p>4 -3 5 -2 -1 2 6 -2</p>
<p>将这个子序列存放在一个数组中来考虑，则有 <code>int a[8] = {4, -3, 5, -2, -1, 2, 6, -2}</code>。</p>
<p>按照分治法的思想，首先将这个序列分为左右两半部分，<strong>分界点</strong> 是<strong>序列首元素在数组中的下标和尾元素在数组中的下标的和除以 2</strong> 所得到的下标值。在上面的序列中，分界点就是 (0 + 7)/2 = 3，也就是说分界点是下标为 3 的元素，即 -2，按照这个分界点，将序列分为两半部分，左半部分子序列为：</p>
<p>4 -3 5 -2</p>
<p>右半部分子序列为：</p>
<p>-1 2 6 -2</p>
<p>我们要在分解后所形成的两个子序列中，分别求最大子序列和，我们不妨用左半部分的子序列来分析一下：</p>
<p>4 -3 5 -2</p>
<p>求这个左半部分子序列的最大子序列和，我们还可以将这个左半部分子序列按照上面提到的方法分解为左半部分和右半部分，由上面的分解方法，得到分界点为下标是 1 的元素，即 -3，由此我们得到左半部分的子序列为：</p>
<p>4 -3</p>
<p>右半部分的子序列为：</p>
<p>5 -2</p>
<p>上面得到的左半部分子序列和右半部分子序列要分别求最大子序列和，同样，这两个子序列仍然可以分解为左半部分和右半部分，针对上面得到的左半部分的子序列，由上面的分解方法，这里省略分解过程，得到最后的左半部分子序列为：</p>
<p>4</p>
<p>右半部分子序列为：</p>
<p>-3</p>
<p>针对 5 -2 ，得到左半部分的子序列为：</p>
<p>5</p>
<p>右半部分的子序列为：</p>
<p>-2</p>
<p>针对上面分解所得到的子序列，每一个子序列只含有一个元素，这是子序列的最简情形，即首元素在数组中的下标和尾元素在数组中的下标相同（首元素和尾元素为同一元素），此时序列不能再进行分解了（ <strong>这种情况将得到递归的基准情形</strong> ）。</p>
<p>考虑上面最后得到的不能分解的子序列，按照最先提到的求最大子序列和的算法思想（1.2.3.4.），可以得到如下结论：</p>
<p>显然，针对序列 4 -3，左半部分子序列的最大子序列和是 4（是左半部分子序列本身）；右半部分子序列的最大子序列和是 -3（是右半部分子序列本身）；左半部分子序列中包含最后一个元素 4 的最大子序列和为 4，右半部分子序列中包含第一个元素 -3 的最大子序列和为 -3，二者求和得到横跨左半部分和右半部分的最大子序列和是 4 + (-3) = 1；在这三者中，左半部分的最大子序列和 4 是最大的，由此得到序列 4 -3 中，最大子序列和是 4。同理，针对序列 5 -2，我们可以用同样的方法得到最大子序列和为 5。</p>
<p>而序列 4 -3 和序列 5 -2 又分别是序列 4 -3 5 -2 的左半部分子序列和右半部分子序列，由此我们得到了序列 4 -3 5 -2 的左半部分子序列的最大子序列和为 4；右半部分的最大子序列和为 5；左半部分子序列中，包含最后一个元素 -3 的最大子序列和是 -3 + 4 = 1，右半部分子序列中，包含第一个元素 5 的最大子序列和为 5，二者求和得到横跨左半部分和右半部分的最大子序列和为 1 + 5 = 6，三者中 6 是最大的，由此，我们得到序列 4 -3 5 -2 的最大子序列和为 6。而序列 4 -3 5 -2 恰好是原序列的左半部分子序列，依照上述求原序列左半部分最大子序列和的方法，同理我们可以很轻松地求出原序列右半部分子序列 -1 2 6 -2 的最大子序列和为 8（不妨在草稿纸上演示一下这个过程），经过以上分析过程，我们得到：</p>
<p>原序列的左半部分子序列的最大子序列和是 6；原序列的右半部分子序列的最大子序列和为 8；在原序列的左半部分子序列中，包含最后一个元素 -2 的最大子序列和是 -2 + 5 + (-3) + 4 = 4，在原序列的右半部分子序列中，包含第一个元素 -1 的最大子序列和是 -1 + 2 + 6 = 7，二者求和得到横跨左半部分与右半部分的最大子序列和是 4 + 7 = 11， 6 8 11 中最大的为 11，由此我们可以得到原序列的最大子序列和为 11。</p>
<p>由以上分析可以看到，求一个序列的最大子序列和，是按照分治法的思想将所给序列逐步分解，分解到不能分解为止（即递归的基准情形），然后再逐步回退，分别求各个分解的子序列的最大子序列和，最后将所有的结果合成在一起得到最后的结果，这里涉及到一个 <strong>反复进行的基本操作</strong> ，就是 <strong>分别求各个分解的子序列的最大子序列和</strong> 。</p>
<p>经过对以上个例的分析，我相信可以更好地理解下面由分治法和递归思想相结合的求最大子序列和的代码了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">MaxSubSum</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> A[], <span class="keyword">int</span> Left, <span class="keyword">int</span> Right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Left == Right)    <span class="comment">/* 递归的基准情形 */</span></span><br><span class="line">        <span class="keyword">return</span> a[Left];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> Center;</span><br><span class="line">    Center = (Left + Right) / <span class="number">2</span>;   <span class="comment">/* 求分界点 */</span></span><br><span class="line">    <span class="keyword">int</span> MaxLeftSum;</span><br><span class="line">    MaxLeftSum = MaxSubSum(A, Left, Center);   <span class="comment">/* 递归，求左半部分子序列的最大子序列和 */</span></span><br><span class="line">    <span class="keyword">int</span> MaxRightSum;</span><br><span class="line">    MaxRightSum = MaxSubSum(A, Center + <span class="number">1</span>, Right);  <span class="comment">/* 递归，求右半部分子序列的最大子序列和 */</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 求横跨左半部分和右半部分的最大子序列和 */</span></span><br><span class="line">    <span class="comment">/* 首先是左半部分子序列中包含最后一个元素的最大子序列和 */</span></span><br><span class="line">    <span class="keyword">int</span> MaxLeftBorderSum = A[Center], LeftBorderSum = A[Center];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Center - <span class="number">1</span>; i &gt;= Left; --i) &#123;</span><br><span class="line">        LeftBorderSum += A[i];</span><br><span class="line">        <span class="keyword">if</span> (LeftBorderSum &gt; MaxLeftBorderSum)</span><br><span class="line">            MaxLeftBorderSum = LeftBorderSum;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 接着是右半部分子序列中包含第一个元素的最大子序列和 */</span></span><br><span class="line">    <span class="keyword">int</span> MaxRightBorderSum = A[Center + <span class="number">1</span>], RightBorderSum = A[Center + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Center + <span class="number">2</span>; i &lt;= Right; ++i) &#123;</span><br><span class="line">        RightBorderSum += A[i];</span><br><span class="line">        <span class="keyword">if</span> (RightBorderSum &gt; MaxRightBorderSum)</span><br><span class="line">            MaxRightBorderSum = RightBorderSum;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Max3 返回左、右半部分子序列的最大子序列和以及横跨左、右半部分的最大子序列和中的最大者 */</span></span><br><span class="line">    <span class="keyword">return</span> Max3(MaxLeftSum, MaxRightSum, </span><br><span class="line">            MaxLeftBorderSum + MaxRightBorderSum);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxSubsequenceSum</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> A[], <span class="keyword">int</span> N)</span>   <span class="comment">/* 求最大子序列和 */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> MaxSubSum(A, <span class="number">0</span>, N - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于测试代码及其最后的运行结果请移步至 <strong>我的GitHub</strong>。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2014/06/30/2014/06-30-algorithms-recursion-rules/" class="prev">PREV</a><a href="/2014/05/31/2014/05-31-c++-deal-string/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'abnerwang';
var disqus_identifier = '2014/06/30/2014/06-30-algorithms-max-subseq/';
var disqus_title = '分治策略结合递归思想求最大子序列和';
var disqus_url = 'http://blog.keeplearning.group/2014/06/30/2014/06-30-algorithms-max-subseq/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//abnerwang.disqus.com/count.js" async></script><div class="copyright"><p>© 2014 - 2019 <a href="http://blog.keeplearning.group">David Wang</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/x-mathjax-config">MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
tex2jax: { inlineMath: [ ["$", "$"], ["\\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
TeX: { noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
messageStyle: "none"
});
</script></body></html>