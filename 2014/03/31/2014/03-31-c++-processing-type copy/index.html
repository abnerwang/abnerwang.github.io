<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> C++ 中的处理类型 · Qiyexuxu</title><meta name="description" content="C++ 中的处理类型 - David Wang"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://blog.keeplearning.group/atom.xml" title="Qiyexuxu"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/logo.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/abnerwang" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">C++ 中的处理类型</h1><div class="tags"><a href="/tags/C/" class="tag-title">#C++</a></div><div class="post-info">Mar 31, 2014</div><div class="post-content"><ol>
<li><p>类型别名</p>
<p>有两种方法可以定义类型别名：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> wages;  <span class="comment">// wages 是 double 的同义词</span></span><br><span class="line"><span class="keyword">typedef</span> wages *p;  <span class="comment">// p 是 double* 的同义词</span></span><br></pre></td></tr></table></figure>
<p>新标准规定了一种新的方法：</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> SI = Sales_item;  <span class="comment">// SI 是 Sales_item 的同义词</span></span><br></pre></td></tr></table></figure>
<p>类型别名和类型名等价，只要是类型的名字能出现的地方，就能使用类型别名</p>
<p>如果某个类型别名指代的是复合类型或常量，那么把它用在声明语句里就会产生意想不到的后果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *pstring;</span><br><span class="line"><span class="keyword">const</span> pstring cstr = <span class="number">0</span>;  <span class="comment">// cstr 是指向 char 的常量指针</span></span><br><span class="line"><span class="keyword">const</span> pstring *ps;  <span class="comment">// ps 是一个指针，它的对象是一个指向 char 的常量指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *cstr = <span class="number">0</span>; <span class="comment">// 是对 const pstring cstr = 0 的错误理解</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>auto</code> 类型说明符</p>
<p>C++ 新标准引入了 auto 类型说明符，用它就能让编译器替我们去分析表达式所属的类型，使用 auto 也能在一条语句中声明多个变量，因为一条声明语句只能有一个基本数据类型，所以语句中所有变量的初始基本数据类型都必须一样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> i = <span class="number">0</span>, *p = &amp;i;  <span class="comment">// 正确，i 是整数，p 是整型指针</span></span><br><span class="line"><span class="keyword">auto</span> sz = <span class="number">0</span>, pi = <span class="number">3.14</span>;  <span class="comment">// 错误，sz 和 pi 的类型不一致</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, &amp;r = i;</span><br><span class="line"><span class="keyword">auto</span> a = r;  <span class="comment">// a 是一个整数，当引用被用作初始值时，真正参与初始化的其实是引用对象的值</span></span><br></pre></td></tr></table></figure>
<p><code>auto</code> 一般会忽略掉顶层 <code>const</code>，同时底层 <code>const</code> 则会保留下来：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = i, &amp;cr = ci;</span><br><span class="line"><span class="keyword">auto</span> b = ci;  <span class="comment">// b 是一个整数（ci 的顶层 const 特性被忽略掉了）</span></span><br><span class="line"><span class="keyword">auto</span> c = cr;  <span class="comment">// c 是一个整数</span></span><br><span class="line"><span class="keyword">auto</span> d = &amp;i;  <span class="comment">// d 是一个整型指针</span></span><br><span class="line"><span class="keyword">auto</span> e = &amp;ci;  <span class="comment">// e 是一个指向整数常量的指针（对常量对象取地址是一种底层 const ）</span></span><br></pre></td></tr></table></figure>
<p>如果希望推断出的 <code>auto</code> 类型是一个顶层 <code>const</code>，需要明确指出：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> f = ci;    <span class="comment">// ci 的推演类型是 int, f 是 const int</span></span><br></pre></td></tr></table></figure>
<p>还可以将引用的类型设为 auto，此时原来的初始化规则仍然适用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> &amp;g = ci;  <span class="comment">// g  是一个整型常量引用，绑定到 ci</span></span><br><span class="line"><span class="keyword">auto</span> &amp;h = <span class="number">42</span>;  <span class="comment">// 错误，不能为非常量引用绑定字面值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> &amp;j = <span class="number">42</span>;  <span class="comment">// 正确，可以为常量引用绑定字面值</span></span><br></pre></td></tr></table></figure>
<p>要在一条语句中定义多个变量，切记，符号 <code>&amp;</code>和 <code>*</code> 只从属于某个声明符，而非基本数据类型的一部分，因此初始值必须是同一种类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> k = ci, &amp;l = i;  <span class="comment">// k 是整数，l 是整型引用</span></span><br><span class="line"><span class="keyword">auto</span> &amp;m = ci, *p = &amp;ci;  <span class="comment">// m 是对整型常量的引用，p 是指向整型常量的指针</span></span><br><span class="line"><span class="keyword">auto</span> &amp;n = i, *p2 = &amp;ci;   <span class="comment">// 错误，i 的类型是 int 而 &amp;ci 的类型是 const int</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>decltype</code> 类型指示符</p>
<p>C++11 新标准引入了 <code>decltype</code>，它的作用是选择并返回操作数的数据类型，但并不实际计算表达式的值，如果使用的表达式是一个变量，则 <code>decltype</code> 返回该变量的类型（包括顶层 <code>const</code> 和引用在内）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">0</span>, &amp;cj = ci;</span><br><span class="line"><span class="keyword">decltype</span>(ci) x = <span class="number">0</span>;    <span class="comment">// x 的类型是 const int</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) y = x;    <span class="comment">// y 的类型是 const int&amp;，y 绑定到变量 x</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) z;        <span class="comment">// 错误，z 是一个引用，必须初始化</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>, *p = &amp;i, &amp;r = i;</span><br><span class="line"><span class="keyword">decltype</span>(r + <span class="number">0</span>) b;    <span class="comment">// 正确，加法的结果是 int</span></span><br><span class="line"><span class="keyword">decltype</span>(r) b;   <span class="comment">// 结果是引用类型</span></span><br><span class="line"><span class="keyword">decltype</span>(*p) c;   <span class="comment">// 错误，c 是 int&amp;，必须初始化</span></span><br></pre></td></tr></table></figure>
<p>如果表达式的内容是解引用操作，则 <code>decltype</code> 将得到引用类型，如上面的 <code>decltype(*p) c;</code>，<code>c</code> 就是一个引用类型<code>decltype</code> 的结果与表达式的形式密切相关，对于 <code>decltype</code> 所用的表达式来说，如果变量名加上了一对括号，则得到的类型与不加括号时有所不同：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// decltype 的表达式如果是加上了括号的变量，结果将是引用</span></span><br><span class="line"><span class="keyword">decltype</span>((i)) d;  <span class="comment">// 错误，d 是 int&amp;，必须初始化</span></span><br><span class="line"><span class="keyword">decltype</span>(i) e;   <span class="comment">// 正确，e 是一个未初始化的 int</span></span><br></pre></td></tr></table></figure>
<p>切记：<code>decltype((variable))</code>（注意是双层括号）的结果永远是引用，而 <code>decltype(variable)</code>结果只有当 <code>variable</code> 本身就是一个引用时才是引用。</p>
</li>
</ol>
</div></article></div></main><footer><div class="paginator"><a href="/2014/04/02/2014/04-02-c++-head-file/" class="prev">PREV</a><a href="/2014/03/27/2014/03-27-c++-void-pointer/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'abnerwang';
var disqus_identifier = '2014/03/31/2014/03-31-c++-processing-type copy/';
var disqus_title = 'C++ 中的处理类型';
var disqus_url = 'http://blog.keeplearning.group/2014/03/31/2014/03-31-c++-processing-type copy/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//abnerwang.disqus.com/count.js" async></script><div class="copyright"><p>© 2014 - 2018 <a href="http://blog.keeplearning.group">David Wang</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>